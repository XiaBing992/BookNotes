# Linux内核简介
Unix强大的根本原因：
1. 简洁：仅仅提供几百个系统调用
2. 一切皆文件
3. Unix的内核和相关系统工具软件是用C语言写的
4. Unix进程创建非常迅速
5. 提供了一套非常简单但又稳定的进程间通信元语

- 在系统中运行的应用程序通过系统调用来与内核通信：应用程序通常调用库函数，再由库函数通过系统调用让内核完成各种不同任务

## 单内核与微内核设计之比较
- 单内核（宏内核）就是整体上作为一个单独的大过程来实现，同时也运行在一个**单独的地址空间**上，所以这样的内核通常以单个静态二进制文件的形式放于磁盘中，所有的内核服务都在这样一个大内核地址空间上运行
  - 简单、性能高：内核之间的通信是微不足道的，因为大家都运行在内核态

- 微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。所有的服务器都保持独立并运行在**各自的地址空间**上。并且只提供一些必要的服务
  - 因此不可能像单模块那样直接调用函数，而是使用IPC（进程间通信）机制互通消息


# 进程管理
## 进程描述符及任务结构
- 内核把进程的列表存放在叫做任务队列的双向链表中
  - 链表中的每一项都是类型为task_struct，称为进程描述符的结构
  - 进程描述符包含一个具体进程的所有信息：它打开的文件、进程的地址空间、挂起的信号、进程的状态等
![img](assets.assets/3.1.png)

## slab机制
- 用于针对一些小块内存及经常分配和释放的对象，如进程描述符

### 分配进程描述符
- Linux通过slab分配器分配task_struct结构

### 进程描述符的存放
- 内核使用PID来标识每个进程

### 进程状态
- 进程描述符中的state域描述了进程的当前状态，系统中的进程必将处于五种进程状态中一种：
  1. TASK_RUNNING(运行)：进程可执行、正在执行、或者在运行队列中等待执行；这是进程在用户空间中执行的唯一可能的状态，也可以应用到内核空间中正在执行的进程
  2. TASK_INTERRUPTIBLE(可中断)：进程正在睡眠（被阻塞），等待条件的达成；一旦条件达成，内核就会把它设置成运行
  3. TASK_UNINTERRUPTRIBLE(不可中断)：除了就算接收信号也不会被唤醒，这个状态与可中断相同
  4. __TASK_TRACED：被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪
  5. ————TASK_STOPPED(停止)：进程停止执行，进程没有投入运行也不能投入运行。通常这种状态发生在收到SIGSTOP、SIGTSTP等信号的时候
![img](assets.assets/3.3.png)

### 设置当前进程状态
- 内核经常需要调整某个进程的状态，使用set_task_state(task, state)函数：
```c
set_task_state(task, state); //将任务task的状态设置为state
```

### 进程上下文
- 一般程序在用户空间执行，一旦执行了某个系统调用或者触发了某个异常，就陷入了内核空间。此时称内核“代表进程执行”并处于进程上下文中
- 除非在此间隙有更高优先级的进程需要执行，否则在内核击退出的时候，程序恢复在用户空间继续执行

### 进程家族树
- 所有进程都是PID为1的init进程的后代
- 内核在系统启动的最后阶段启动init进程，该进程读取系统的初始化脚本并执行其他的相关程序，最终完成整个系统启动的整个过程
- 进程间的关系放在进程描述符中，每个task_struct都包含一个指向其父进程task_struct，叫做parent的指针，还包含一个称为children的子进程链表

## 进程创建
- UNIX将创建进程分解到两个单独的函数中执行：fork() 和 exec();
- fork通过拷贝当前进程创建一个子进程
- exec函数负责读取可执行文件并将其载入地址空间开始运行

### 写时拷贝
- COW：将复制操作推迟到第一次写的时候进行。内核会保留每个页面的引用计数，每次复制某个页面时，引用计数减一，当页面只有一个引用时，跳过复制，直接修改
- 传统的fork()系统调用直接把所有的资源给新创建的进程，这种实现过于简单 并且效率低下
- Linux的fork()使用*写时拷贝页*实现。写时拷贝时一种可以推迟甚至免除拷贝数据的技术；内核此时并不复制整个进程空间，而是让父进程和子进程共享同一个拷贝
- 只有在需要写入时，数据才会复制，从而使各种进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享
- 在页根本不会被写入的情况下，就无需复制了
- fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符
- 在一般情况下，进程创建后会马上运行一个可执行文件的程序，这种优化可以避免拷贝大量根本就不会被使用的数据
总结：fork之后，kernel会把父进程的内存页都设置成read-only，然后将子进程页指向父进程页。当父子进程都只读内存时，相安无事。当其中某个进程开始写内存时，CPU硬件检测到内存页时read-only的，触发页异常中断，陷入kernel的中断例程。中断例程中，kernel就会把触发异常的页复制一份，于是父子进程各自持有独有的一份。

- COW优缺点：
  1. 可减少分配和复制带来的瞬时延迟
  2. 减少不必要资源的复制。比如fork时，父进程的代码段和只读数据段都不允许修改，所以无需修改
  3. 如果在fork之后，父子进程都产生了大量的写操作，会产生大量的页错误

### fork()
- Linux通过clone()系统调用实现fork()
- fork()、vfork()、__clone()库函数都根据自己需要的参数调用clone()，然后由clone()调用do_fork()

### vfork()
- 除了**不拷贝父进程的页表**外，vfork()和fork()功能相同(fork支持COW后，已经一样了)
- 子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行exec()

fork和vfork区别：
1. vfork主要是早期fork不支持COW时使用，目的就是在vfork后直接调用exec()
2. 两者现在主要的区别是前者生成的是进程，后者生成的是线程
3. vfork会导致父进程阻塞，fork使用时父子进程调度顺序未知
4. 在支持COW的情况下，fork相比vfork还是多拷贝了一些东西，如页表、mm struct(用于虚拟地址空间的描述)这两个结构

## 线程在Linux中的实现
- Linux内核角度来说，并没有线程的概念，Linux把所有的线程都当成进程来实现，每个线程都拥有唯一属于自己的task_struct
- 线程仅仅被视为一个与其他进程共享某些资源的进程
- 在Windows和SUN solaris等操作系统中差异非常大，是在内核中提供了专门支持线程的机制

### 创建线程
- 线程的创建和普通进程的创建类似，只不过在调用clone的时候需要传递一些参数标志来指明需要共享的资源
```c
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0) // 父子进程共享地址空间、文件系统信息、打开的文件、信号处理函数以及被阻断的信号
```
- clone 的参数标志：
![img](assets.assets/t3.1.png)
![img](assets.assets/t3.1.2.png)

### 内核线程
- 独立运行在内核空间的标准进程
- 内核线程和普通进程进程之间的区别在于内核线程没有独立的地址空间（指向地址空间的mm指针被设置为NULL），它们只在内核空间运行
- 内核线程是通过kthread内核进程通过clone系统调用创建的

## 进程终结
- 僵尸进程：子进程已经结束，但是父进程没有来得及回收子进程，子进程的PID仍然保留在系统中
- 进程的总结大部分要靠do_exit()来完成
- 调用后与进程相关联的所有资源都被释放掉了并处于EXIT_ZOMBIE退出状态
- 进程占用的内存只有内核栈、thread_info、task_struct结构
- 此时进程存在的目的就是向他的父进程提供信息

### 删除进程描述符
- 前面可以看出，进程终结时所需要的清理工作和进程描述符删除被分开执行
- 在父进程**获得已终结的子进程的信息**后，或者**通知内核它并不关注那些信息**后，子进程的task_struct结构才被释放

### 孤儿进程造成的进退维谷
- 父进程在子进程之前退出
- 给当前子进程在当前线程组内找一个线程作为父亲，如果不行，就让init作为父进程


# 进程调度
- 自Linux2.6后，采用了RSDL(反转楼梯最后期限调度算法)算法替代O(1)算法，将公平调度的概念引入Linux调度程序；也被称为完全公平调度算法，或者称为CFS

## 策略
### I/O消耗型和处理器消耗型的进程
- 前者指进程的大部分时间用来提交I/O请求或是等待I/O请求，这样的进程常常只运行短短一会儿，由于在等待更多的I/O请求时最后总会阻塞
- 处理器耗费型进程把时间大多数用在执行代码上，除非被抢占，否则将不停的运行
- 调度策略通常要在两个矛盾的目标中间寻找平衡：响应时间和高吞吐量

### 进程优先级
- Linux采用了不同的优先级范围
- 一种时nice值，范围为-20到+19，默认值为0；nice值代表分配给进程的时间片比例；越大的nice值意味着更低的优先级，获得更少的处理器时间
- 第二种是实时优先级，其值是可配置的，变化范围为0-99；越高的实时优先级数值意味着进程优先级越高，任何实时进程的优先级都高于普通的进程
- 两者互不干涉

### 时间片
- Linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比划分给了进程；因此进程所获得的处理器时间是和系统负载密切相关的，这一比例还会受nice值影响（权重）

## Linux调度算法

### 调度器类
- Linux调度器是以模块方式提供的，这样做的目的是可以允许不同进程可以针对性的选择调度算法
- 这种模块化的结构被称为调度器类，每个调度器都有一个优先级，会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行哪一个程序
- CFS是一个针对普通进程的调度类

### Unix系统中的进程调度

### 公平调度
- 任何进程的处理器时间是由它自己和其他所有可运行进程nice值得**相对差值**决定的

## Linux调度得实现
### 时间记账
1. 调度器实体结构
   - 调度器实体结构作为一个名为se的成员变量，嵌入在进程描述符task_struct内
![img](assets.assets/c4.1.png)

2. 虚拟实时
   - vruntime存放的是进程的虚拟运行时间，该运行时间是被加权后的

### 进程选择
- 当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程
- CFS使用红黑树来组织可运行进程队列，并利用其找到最小vruntime值得进程

1. 挑选下一个任务
   - vruntime最小得进程对应树中最左边的叶子节点
   - 最左侧的叶子节点是缓存起来的，所以可以实现O(1)时间查找

2. 向树中加入进程
   - 发生在进程变为可运行状态或者fork()调用第一次创建进程时

3. 从树中删除进程
   - 发生在进程阻塞或者终止时

### 睡眠和唤醒
- 休眠的进程有两种状态：TASK_INTERRUPTIBLE（如果收到信号会提前唤醒响应信号）和TASK_UNINTERRUPTIBLE（进程会忽略信号）
1. 等待队列：由等待某些事件发生的进程组成的简单链表
   - 当与等待队列相关的事件发生的时候，队列上的进程会被唤醒
   - 如果状态被设置为TASK_INTERRUPTIBLE，则信号唤醒进程。这会导致虚假唤醒，因此检查并处理信号
![img](assets.assets/c4.2.png)

2. 唤醒
   - 唤醒操作通过函数wake_up进行，它会唤醒指定的等待队列上的所有进程
   - 该函数将进程设置为TASK_RUNNING状态，调用enqueue_task()将此进程放入红黑树中

## 抢占和上下文切换
- 从一个进程切换到另一个进程，有context_switch()函数负责处理，schedule()负责调用该函数，完成两项基本工作：
  1. 调用switch_mm()函数，负责把虚拟内存从上一个进程映射切换到新进程中
  2. 调用switch_to()，负责从上一个进程处理器状态切换到新进程的处理器状态；包括保存、恢复栈信息和寄存器信息等

- 内核提供了一个need_resched标志（task_struct中）来表明是否需要重新执行一次调度；当某个进程应该被抢占时，scheduler_tick()就会设置这个标志，内核检查该标志，确认其被设置，调用schedule()来切换到一个新的进程


### 用户抢占
- 内核即将返回用户空间时，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占
- 用户抢占在以下情况时发生：
  1. 从系统调用返回用户空间时
  2. 从中断处理程序返回用户空间时

### 内核抢占
- Linux完整的支持内核抢占；在不支持内核抢占的内核中，内核代码可以一直执行，到它完成为止
- 什么时候重新调度时安全的？
  - 只要没有持有锁，内核就可以进行抢占，锁时非抢占区域的标志
- 为了支持内核抢占，为每个进程的thread_info引入preempt_count计数器；该计数器每当使用锁的时候值加1，释放锁的时候值减一，当数值为0时，内核就可以执行抢占
- 从中断返回内核空间时，内核会检查need_resched和preempt_count的值，如果need_esched被设置，并且preempt_count为0的话，说明有一个更加重要的任务需要执行并且可以安全的抢占，此时调度程序就会被调用；如果preempt_count不为0，说明当前任务持有锁，抢占不安全，会直接从中断返回当前执行进程；如果当前进程持有的所有锁都被释放了，此时释放锁的代码会检查need_resched是否被设置；如果是，会调用调度程序
- 如果内核进程被阻塞了，或者显式的调用了schedule()，内核抢占也会显式的发生

- 内核抢占发生在：
  1. 中断处理程序正在执行，且返回内核空间前
  2. 内核代码再一次具有可抢占性的时候
  3. 内核中的任务显示调用schedule()
  4. 内核中的任务阻塞

## 实时调度策略
- Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR；而普通的、非实时的策略是SCHED_NORMAL
- 借助调度类的框架，这些任务不被完全公平调度器管理，而是被一个特殊的实时调度器管理
- 都使用静态优先级，但是Linux地实时调度算法提供地是一种软实时工作方式

- SCHED_FIFO：不使用时间片，**处于SCHED_FIFO级的进程会比任何SCHED_NORMAL级的进程都先得到调度**（我的理解是，CFS的进程就是SCHED_NORMAL）；一旦一个SCHED_FIFO级的进程处于可执行状态，它会一直执行，直到自己受阻塞或显示地释放处理为止；只有更高优先级地SCHED_FIFO或者SCHED_RR任务才能抢占SCHED_FIFO任务才能抢占SCHED_FIFO任务
- SCHED_RR：在进程耗尽实现分配地时候后就不能继续执行了（带有时间片地 SCHED_FIFO）

## 与调度相关地系统调用
![img](assets.assets/t4.2.png)

### 与处理器绑定有关的系统调用
- Linux调度程序提供强制的处理器绑定机制，允许用户指定进程一定在哪些处理器上运行（在task_struct的cpus_allowed位掩码中，默认情况下，所有的位都被设置）

### 放弃处理器时间
- Linux通过sched_yield系统调用，提供了让进程显示的将处理器时间让给其他等待执行进程的机制
- 通过从活动活动队列移到过期队列实现（确保一段时间都不会在执行）；实时进程不会过期，只被移动到优先级队列的最后面

# 系统调用
- 用户进程和内核进行交互的一组接口
- 系统调用在用户进程和硬件设备之间添加了一个中间层，主要作用：
  1. 为用户空间提供了一种硬件的抽象接口
  2. 系统调用保证了系统的稳定和安全：避免应用程序不正确地使用硬件设备
  3. 为每个进程运行在虚拟系统的一种考虑

### 系统调用号
- Linux中，每个系统调用被赋予一个系统调用号，一旦分配就不能有任何更改；如果一个系统调用被删除，它所占用的系统调用号也不允许回收利用
- 当用户空间的进程执行一个系统调用的时候，这个系统调用号就用来指明到底是要执行哪个系统调用，进程不会提及系统调用的名称
- Linux有一个"未实现"系统调用sys_ni_syscall()，返回-ENOSYS，这个错误号就是专门针对无效的系统调用而设的
- 内核记录了系统调用表中所有已注册过的系统调用的列表

### 系统调用的性能
- Linux系统调用比其他许多操作系统执行的要快：短的上下文切换和每个系统调用简洁高效

## 系统调用处理程序
- 用户空间无法直接执行内核代码
- 通知内核的机制是使用软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序，此时的异常处理程序就是系统调用程序
- 在X86系统上，预定义的软中断号是128，通常用int $0x80指令触发该中断（system_call()系统调用）

### 指定恰当的系统调用
- 陷入内核空间的时候需要把系统调用号一起传给内核
- 在X86上，系统调用号是通过eax寄存器传递给内核的，在陷入内核之前，用户空间就得把相应的系统调用号放入eax中

### 参数传递
- 除了系统调用号外，大部分系统调用都还需要将一些参数传入；所以在发生陷入时，还要把这些参数从用户空间传入内核
- 最简单的方法是把这些参数也放在寄存器里
- 给用户空间的返回值也通过寄存器传递，在X86上，放在eax寄存器中
![img](assets.assets/5.2.png)

## 系统调用的实现